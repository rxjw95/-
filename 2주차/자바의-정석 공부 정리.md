# 자바의 정석

chapter 5. [Array](#Array-주요-정리)
chapter 6. [Object-Oriented programming 1](#Object-Oriented-programming-1)
chapter 7. [Object-Oriented programming 2](#Object-Oriented-programming-2) 

## Array 주요 정리

### 배열
- 같은 타입의 여러 변수를 하나의 묶음으로 다루는 것을 `배열`이라고 한다.

```java
int[] arr; //참조 변수를 위한 공간 생성
arr = new int[배열의 크기];  //실제 값을 저장할 수 있는 배열 공간 생성
```

> 이 때 arr는 값을 저장하기 위한 공간이 아니고 배열을 다루기 위한 참조 변수라는 것을 기억하자.

또한, new 연산자로 배열을 만들게 되면 각 배열 요소는 자동적으로 타입의 default 값으로 초기화가 된다.
예를 들어, int는 0, double는 0.0, char은 '', boolean은 false 등 

### 배열의 길이와 인덱스
- 배열의 요소마다 붙여진 일련 번호를 인덱스라고 한다.
- 인덱스의 범위는 0부터 (배열의 길이 - 1)까지이다.

> 배열의 길이는 int범위의 양의 정수(0 포함)이다.

여기서 길이가 0이 될 수 있다는 것을 알아두자.

```java
int[] arr = new int[5];
int len = arr.length; // 5
arr.length = 7; //error
```


### 배열 초기화
```java

int[] arr = new int[2];

//first
arr[0] = arr[1] = 3;

//second
for(int i = 0; i < arr.length; i++) {
    arr[i] = 3;
}

//third
int[] arr3 = new int[]{1, 2, 3};

//fourth
int[] arr4 = {3, 4, 5}; //이와 같으 방법은 한줄에 걸쳐 작성해야한다.

```

### 배열의 복사

- 얕은 복사(swallow copy)
다른 객체를 복사할 때, 해당 객체의 참조 값을 복사하여 새 객체에 할당한다.
기존의 객체와 복사된 새 객체 모두 같은 메모리 주소를 가리키고 있기 때문에 하나의 객체를 수정하면 다른 객체도 그 값이 변경되게 된다.

```java

int[] a = new int[]{1, 2, 3}
int[] b = a;

b[0] = -3;

System.out.println(a[0]) // -3

```


- 깊은 복사(deep copy)
다른 객체를 복사할 때, 해당 객체의 변수(참조 변수)를 할당하지 않고 복사할 객체 내 각 요소의 값을 새 객체에 복사한다.
기존의 객체와 복사된 새 객체가 같은 요소를 가지지만 서로 독립적으로 메모리를 사용하게 되어 특정 객체의 값을 수정해도 다른 객체는 그 값이 변경되지 않는다.

```java

int[] a = new int[]{1, 2, 3}
int[] b = new int[3];

//first
for(int i = 0; i < a.length; i++)    b[i] = a[i]; //요소의 값 복사

//second
System.arraycopy(a, 0, b, 0, a.length); //for문보다 빠르고 간단하게 사용할 수 있다.

```


## String 배열

일반 Primitive type의 배열 선언 방식과 동일하다.

> 참조형 변수의 배열 선언 시 초기값은 null 이다.

다시 생각해보자면, String 배열은 참조형 변수들의 배열이다.

그렇기 때문에 각 배열의 요소 또한 참조형이라는 것을 알고 있어야 한다.

```java

String[] strs = new String[3]; //각 String 요소들은 null

strs[0] = "ryu"; //"ryu"가 저장되어 있는 메모리의 참조 주소를 저장하는 것과 같다.

```

String 클래스는 어떻게 보면 char 배열과 같은 의미를 지니는데, 문자열을 편하게 다루기 위해 char 배열과 그에 관련된 기능을 함께 묶어서 클래스에 정의한다.
그리고 String 클래스와 char 배열의 차이는 String 클래스는 한번 문자열을 저장하면 수정할 수 변경할 수 없다. 즉, read-only


#### String 클래스의 주요 메서드

|메서드|설명|
|------|---|
|char charAt(int idx)|문자열에서 해당 인덱스에 있는 문자를 반환한다.|
|int length()|문자열의 길이를 반환한다.|
|String substring(int from, int to)|문자열에 해당 범위에 있는 문자열을 반환한다.(to는 포함하지 않는다.)|
|char[] toCharArray()|문자열을 문자배열로 변환해서 반환한다.|
|boolean equals(Object obj)|문자열의 내용이 obj와 같은지 확인한다. 같으면 true, 다르면 false|

```java

String str = "안녕하세요우";

str.charAt(0); //'안'
str.length(); // 6
str.substring(0, 1); //'안'
str.equals("안녕하세요우") //true;

char[] chars = str.toCharArray();

String newStr = new String(chars);

```

## Object-Oriented programming 1

### 객체지향언어의 역사

- 객체지향이론의 탄생은 과거 과학실험이나 미사일 발사실험과 같은 모의실험을 실제 세계와 유사한 가상 세계를 컴퓨터 속에 구현하고자 노력하는 과정에서 탄생하게 되었다.

- 객체지향이론의 기본 개념은 `실제 세계는 사물로 이루어져 있으며, 발생하는 모든 사건들은 사물간의 상호작용이다.`

즉, 실제 사물의 속성과 기능을 분석한 다음, 데이터(변수)와 함수로 정의함으로써 실제 세계를 컴퓨터 속에 옮겨 놓은 것과 같은 가상 세계에서 모의 실험을 함으로써 많은 시간과 비용을 아끼게 되었다.

객체지향이론은 상속, 캡슐화, 추상화 개념을 중심으로 점차 구체적으로 발전되었으며 시뮬라(Simula)라는 최초의 객체지향 언어가 탄생했다.

### 객체지향언어의 주요 특징

- 코드의 재사용성이 높다. : 새로운 코드를 작성할 때 기존의 코드를 이용해서 쉽게 작성할 수 있다.
- 코드의 관리가 용이하다. : 코드간의 관계를 이용해서 적은 노력으로 쉽게 코드를 변경할 수 있다.
- 신뢰성이 높은 프로그래밍을 가능하게 한다. : 제어자와 메서드를 이용해서 데이터의 무결성을 지키고 중복을 줄여 코드 불일치로 인한 오동작을 줄인다.

### 클래스와 객체

- 
